Come si inserisce il modello open-source in un panorama tecnologico sempre più accentrato nelle mani di **poche e potenti aziende**? Il timore è infatti quello che rendendo il codice disponibile a tutti si potrebbe subito essere vittima di plagio da parte di giganti del settore in grado di realizzare in poco tempo ciò che prenderebbe a un team open-source diversi mesi, strappando così una grande fetta di mercato. James smentisce tale idea nel suo [articolo](https://web.archive.org/web/20081015010505/http://www.moonviewscientific.com/essays/software_lifecycle.htm), in cui descrive il ciclo di vita di un software **FOSS** (Free and Open Source Software) come la sequenza di tali fasi:
1. **Invenzione**: qualcuno ha avuto un'idea e la implementa facendola funzionare. Dal momento in cui l'idea viene resa pubblica si assiste a una grossa esplosione di progetti finanziati da varie aziende che cercano di diventare leader nel nuovo mercato.
2. **Espansione e innovazione**: il mondo si accorge dell'invenzione e la tecnologia inizia a espandersi in quanto le aziende si rincorrono a vicenda cercando di aggiungere più funzionalità possibili. Questa fase non rappresenta un buon momento per far nascere un progetto open source: un piccolo gruppo non riuscirebbe a prevalere sulle grandi aziende. Dato che poi le specifiche non sono ancora ben definite si rischierebbe di implementare funzionalità inutili.
3. **Consolidamento**: i prodotti di certe aziende iniziano a dominare il mercato, mentre i competitor vengono assorbiti, falliscono o diventano di nicchia (l’azienda fornisce il prodotto con delle particolarità non presenti altrove). Diminuisce complessivamente il numero di soggetti coinvolti e l’innovazione rallenta.
4. **Maturità**: il problema e le specifiche sono adesso ben chiare e consolidate. Per un prodotto commerciale è ormai difficile entrare nel mercato, mentre per uno open source è invece il **momento migliore**: il piccolo team ha uno slancio innovativo che le grosse aziende non hanno più e il loro prodotto può godere dei vantaggi del mondo open, tra cui sicurezza e flessibilità. 
   L'esempio lampante è quello di Linux: Linus Torvalds sapendo già tutti i concetti base di un sistema operativo grazie a Minix (OS didattico creato da Tanenbaum per i suoi studenti, tra cui Torvalds), creò il kernel di Linux. Inizia in un momento storico in cui le specifiche per creare un OS sono ben chiare, perciò c'è poca innovazione nel settore e quindi può far nascere un'alternativa che ha dalla sua parte i vantaggi del mondo open.
5. **Passaggio tra maturità e FOSS Domination**: quando un prodotto open source diventa famoso le aziende ne soffrono, di conseguenza hanno iniziato a sfruttare anch'esse le idee di altri per il proprio prodotto. 
   Esempio IBM, che inizialmente vendeva i prodotti col sistema sviluppato da loro, ma quando Linux si affermò lo sfruttarono smettendo di fornire il loro sw e offrendo supporto per Linux. Solaris invece decise di rendere open source il proprio OS ma questo venne dimenticato in poco tempo, in quanto le componenti che aveva in più rispetto a Linux vennero subito prese e integrate a quest’ultimo.
6. **FOSS Domination**: lentamente il prodotto open source inizia a superare il vantaggio tecnologico dei competitor commerciali, che d'altro canto non hanno alcun interesse a innovare ancora: ciascuna loro innovazione potrebbe infatti essere facilmente copiata ed essi sono inoltre già largamente rientrati del loro investimento iniziale. Il prodotto open inizia a dominare certe fette di mercato.
7. **FOSS era**: alla fine il progetto open-source domina completamente il nuovo mercato, mentre le grandi aziende devono ripiegare sulla vendita di servizi più che di software. Questa è una situazione ideale, probabilmente utopica, che fino ad oggi non è mai successa.

Il vantaggio di un progetto open-source non è dunque tanto la velocità di espansione o l’abilità di catturare il mercato, quanto il fatto che esso permetta una **continua innovazione che segue le necessità del mercato**, cosa che le grandi aziende faticano a conseguire in quanto ancora legate a un paradigma di investimento in cui una volta fatto il lavoro e guadagnato un tot, è più costoso fare manutenzione del software piuttosto che lasciarlo morire (hey Google?).